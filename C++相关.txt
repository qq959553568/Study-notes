template<typename T>
void Swap(T&a ,T&b)
{
	T temp= a;
	a=b;
	b=temp;
}(函数模板）
作用域解析符号::
类定义了一个新的作用域，类的所有成员都在类的作用域中。再类体外定义成员，需要使用作用域解析符指明成员属于哪个类域
成员变量在类中声明次序就是其在初始化列表中的初始化顺序，与其在初始化列表中的先后次序无关
初始化列表
public:
	B(int b = 0)
		:_b(b)
	{}
	int _b;
}；

友元函数不属于任何类，但需要在类的内部声明，声明时需要加friend关键字

（C中的）1.malloc/calloc/realloc的区别是什么？
malloc在堆上开辟对应字节的空间，不初始化
calloc开辟对应字节的空间并初始化为0
realloc调整应经动态开辟空间的大小，可以扩容也可以缩小
（C++）new和delete操作自定义类型
在申请自定义类型的空间时，new会调用构造函数，delete会调用析构函数，而malloc与free不会。

const修饰指针变量有三种情况（左定值，右定向，const修饰不变量）
A: const 修饰指针指向的内容，则内容为不可变量。
B: const 修饰指针，则指针为不可变量。
C: const 修饰指针和指针指向的内容，则指针和指针指向的内容都为不可变量。

A:const int *p =8(常量指针，修饰内容不可变，即8不可变）
B:
int a = 8;
int* const p = &a;
*p = 9; // 正确
int  b = 7;
p = &b; // 错误（指针常量，指针指向的内存地址不能变）
C:
int a = 8;
const int * const  p = &a;(二者的结合，指针指向的内存地址和指向的内容都不可变）

有了虚函数，基类指针指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就使用派生类的成员。换句话说，基类指针可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有多种形态，或者说有多种表现方式，我们将这种现象称为多态（Polymorphism）。

多态一般指的是指针，引用可以实现多态。
只需要在虚函数的声明处加上 virtual 关键字，函数定义处可以加也可以不加
为了方便，只将基类中的函数声明为虚函数，这样所有派生类中具有遮蔽（覆盖）关系的同名函数都将自动成为虚函数
构成多态的条件：
必须存在继承关系；
继承关系中必须有同名的虚函数，并且它们是遮蔽（覆盖）关系。
存在基类的指针，通过该指针调用虚函数。
通过基类的指针只能访问从基类继承过去的成员，不能访问派生类新增的成员。
首先看成员函数所在的类是否会作为基类。然后看成员函数在类的继承后有无可能被更改功能，如果希望更改其功能的，一般应该将它声明为虚函数。如果成员函数在类被继承后功能不需修改，或派生类用不到该函数，则不要把它声明为虚函数。

（线-矩形-长方体-正方体）可以发现，Line 类表示“线”，没有面积和体积，但它仍然定义了 area() 和 volume() 两个纯虚函数。这样的用意很明显：Line 类不需要被实例化，但是它为派生类提供了“约束条件”，派生类必须要实现这两个函数，完成计算面积和体积的功能，否则就不能实例化

静态成员函数没有this指针，只能访问静态成员(包括静态成员变量和静态成员函数）
普通成员函数有this指针，可以访问类中的任意成员；而静态成员函数没有this指针。